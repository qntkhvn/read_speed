---
title: Analysis of CSV File Reading in R
author:
  - Quang Nguyen
  - Robert Tedesco
date: STAT 407 Fall 2021
output: 
  pdf_document: 
    number_sections: true
    df_print: kable
abstract: "write some stuff"
header-includes:
 \usepackage{setspace}
 \setlength{\parskip}{3mm}
 \onehalfspacing
 \usepackage{float}
 \floatplacement{figure}{H}
 \usepackage[skip=4pt]{caption}
bibliography: ref.bib
csl: apa.csl
indent: true
geometry: margin=1.1in
fontsize: 12pt
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(message = FALSE,
                      echo = FALSE,
                      warning = FALSE,
                      fig.pos = "H")
```

```{r}
library(tidyverse)
theme_set(theme_bw())
library(patchwork)
library(broom)
library(car)
library(rcompanion)
```

```{r}
res <- bind_rows(read_csv("res_quang.csv"),
                 read_csv("res_rob.csv"),
                 read_csv("res_lance.csv")) %>% 
  mutate(computer = str_replace(computer, "lance", "dell"),
         computer = str_replace(computer, "rob", "lenovo"),
         computer = str_replace(computer, "quang", "mac"),
         
         across(where(is_character), factor))
```


\newpage

# Introduction

Data importing is undoubtedly a crucial part of a modern statistics and data science workflow, as it is the first step that paves the path for important stages such as data wrangling, visualizing, and modeling. With modern computers, loading data may seem like a straightforward task for a statistician. However, as the volume of data increases, this imposes a new set of challenges related to computing time and efficiency for data importing. A researcher may have to load a large data file multiple times a week in order to perform statistical analyses, which could potentially cost them valuable time. Identifying the fastest computing techniques is a necessity in the computational problem of working with big data.

The `R` programming language [@baser] is well-known among statisticians and data scientists as a powerful tool for working with data. In `R`, a popular method used by traditional statisticians to load a comma-separated values (CSV) file into the environment is `read.csv()`, which is a built-in base function. However, there are some drawbacks with this method, when working with large data sets. As demonstrated by @gregcsv, it took minutes to import a CSV file of about two-gigabyte containing over a million rows of NFL tracking data with the historical `read.csv()` function in base `R`. Fortunately, in recent years, `R` developers have come up with better ways to read in data files. As mentioned by @efficient in their "Efficient R programming" book, there are three modern functions/packages that `R` users should take advantage of in order to improve file-reading performance. 

The first function that `R` programmers should consider is `import()`, which comes from the `rio` package [@rio]. As described by its creators in the package documentation, `rio` is  "a swiss-army knife for data I/O".  The function `import()` in `rio` essentially simplifies the data importing process since as a function by itself, `import()` has the flexibility of reading in multiple file extensions, such as `.json`, `.xls`, `.xlsx`, in addition to the common `.csv`.  The data is stored as a `data.frame` object after being loaded into `R` in using `import()`.

Another `R` package for importing data that has gotten a lot of attention recently is `readr` [@readr], which is also part of the popular `tidyverse` collection of packages [@tidyverse] for modern data science. Within `readr`, there is a `read_csv()` function for getting CSV files into `R`, alongside other functions of the `read_*()` family designed for other file extensions. A notable aspect of the functions in `readr` in general and `read_csv()` in particular is the data is stored as a `tibble` (a "modern" `data.frame`-typed object) in the `R` environment once it is read in.

The third and final package for efficient file reading in `R` is `data.table` [@datatable], which contains the `fread()` function for data importing. As an individual function, `fread()` is also capable of loading a variety of file extensions, similar to `rio::import()`. As for object type, the `fread()` function imports and returns a data object of classes `data.table` and `data.frame`.

In this paper, we attempt to design a three-factor factorial experiment and perform analyses to compare the speed of the three CSV importing algorithms in `R` as mentioned in previous paragraphs. In particular, the independent variables we are interested in examining are 1) the `R` packages/functions; 2) the file size; and 3) the computer device. The paper is outlined as follows. We first describe our data generating process for our experiment and the methodologies used for analyses in Section 2. We then spend the next section, 3, on our analyses and results of this experiment. Lastly, in Section 4, we give a quick summary of our results as well as discuss possible future work related to this project.

# Experiment

# Analysis of Variance

```{r}
p1 <- res %>% 
  group_by(size, package) %>% 
  summarize(avg_time = mean(time)) %>% 
  ungroup() %>% 
  ggplot(aes(size, avg_time)) +
  geom_line(size = 1, aes(group = package, color = package)) +
  geom_point(size = 2.5, aes(color = package), shape = 15) +
  theme(legend.position = "bottom")

p2 <- res %>% 
  group_by(size, computer) %>% 
  summarize(avg_time = mean(time)) %>% 
  ungroup() %>% 
  ggplot(aes(size, avg_time)) +
  geom_line(size = 1, aes(group = computer, color = computer)) +
  geom_point(size = 2.5, aes(color = computer), shape = 15) +
  theme(legend.position = "bottom")

p3 <- res %>% 
  group_by(package, computer) %>% 
  summarize(avg_time = mean(time)) %>% 
  ungroup() %>% 
  ggplot(aes(package, avg_time)) +
  geom_line(size = 1, aes(group = computer, color = computer)) +
  geom_point(size = 2.5, aes(color = computer), shape = 15) +
  theme(legend.position = "bottom")
```

```{r, fig.width=12, fig.height=4.5, fig.cap="Interaction plots"}
p1 + p2 + p3
```

```{r}
mod <- lm(time ~ computer * size * package, data = res)
mod %>% 
  anova() %>% 
  tidy() %>% 
  knitr::kable(caption = "ANOVA output")
```

```{r}
pqq <- tibble(resid = resid(mod)) %>% 
  ggplot(aes(sample = resid)) +
  stat_qq() + 
  stat_qq_line(linetype = "dashed")

prvf <- tibble(resid = resid(mod),
             fitted = fitted(mod)) %>% 
  ggplot(aes(fitted, resid)) +
  geom_point() +
  geom_hline(yintercept = 0, linetype = "dashed")
```

```{r, fig.width=6, fig.height=3, fig.cap="Residuals plots"}
pqq + prvf
```


```{r}
mod %>% 
  pluck("residuals") %>% 
  shapiro.test() %>% 
  tidy() %>% 
  knitr::kable(caption = "Shapiro-Wilk test for normality")
```

```{r}
leveneTest(time ~ computer * size * package, data = res) %>% 
  tidy() %>% 
  knitr::kable(caption = "Levene's Test for Homogeneity of Variance (center = median)")
```

Mention other transfomations, put in appendix

Permutation

```{r}
perm.fact.test <- function(Y,
                           X1,
                           X2,
                           X3 = NA,
                           perm = 100,
                           method = "a") {
  if (all(is.na(X3))) {
    init.model <- anova(lm(Y ~ X1 * X2))
  }
  if (all(!is.na(X3))) {
    init.model <- anova(lm(Y ~ X1 * X2 * X3))
  }
  
  r <- length((init.model)$"F value") - 1
  F.init <- init.model$"F value"[1:r]
  MS <- init.model$"Mean Sq"
  
  # (a)
  if (method == "a") {
    F.perm <- matrix(nrow = r, ncol = perm)
    if (all(is.na(X3))) {
      for (i in 1:perm) {
        Y.new <- sample(Y, replace = FALSE)
        F.perm[, i] <- anova(lm(Y.new ~ X1 * X2))$"F value"[1:r]
      }
    }
    
    if (all(!is.na(X3))) {
      for (i in 1:perm) {
        Y.new <- sample(Y, replace = FALSE)
        F.perm[, i] <- anova(lm(Y.new ~ X1 * X2 * X3))$"F value"[1:r]
      }
    }
  }
  
  
  # (b)
  if (method == "b") {
    MS.perm <- matrix(nrow = r + 1, ncol = perm)
    if (all(is.na(X3))) {
      for (i in 1:perm) {
        Y.new <- sample(Y, replace = FALSE)
        MS.perm[, i] <- anova(lm(Y.new ~ X1 * X2))$"Mean Sq"
      }
    }
    
    if (all(!is.na(X3))) {
      for (i in 1:perm) {
        Y.new <- sample(Y, replace = FALSE)
        MS.perm[, i] <- anova(lm(Y.new ~ X1 * X2 * X3))$"Mean Sq"
      }
    }
    
    F.perm <- matrix(nrow = r, ncol = perm)
    for (i in 1:perm) {
      F.perm[, i] <- MS.perm[, i][1:r] / MS.perm[, i][r + 1]
    }
  }
  
  p1 <- matrix(nrow = r, ncol = perm)
  for (i in 1:r) {
    p1[i, ] <- F.perm[i, ] >= F.init[i]
  }
  
  p2 <- apply(p1, 1, function(x) {
    length(x[x == TRUE])
  })
  
  p.val <- (p2 + 1) / perm
  p.val <- ifelse(p.val > 1, 1, p.val)
  
  if (all(is.na(X3))) {
    Table <-
      data.frame(
        Initial.F = init.model$"F value",
        Df = init.model$"Df",
        row.names = c("X1", "X2", "X1:X2", "Residual"),
        pval = c(p.val, NA)
      )
  }
  if (all(!is.na(X3))) {
    Table <-
      tibble(
        Term = c(
          "X1",
          "X2",
          "X3",
          "X1:X2",
          "X1:X3",
          "X2:X3",
          "X1:X2:X3",
          "Residual"
        ),
        InitialF = init.model$"F value",
        DF = init.model$"Df",
        pval = c(p.val, NA)
      )
  }
  res <- list()
  res$Table <- Table
  res
}

set.seed(69)
perm <- perm.fact.test(Y = res$time,
                       X1 = res$size,
                       X2 = res$computer,
                       X3 = res$package,
                       perm = 9999)

perm$Table %>% 
  mutate(Term = str_replace(Term, "X1", "size"),
         Term = str_replace(Term, "X2", "computer"),
         Term = str_replace(Term, "X3", "package")) %>% 
  knitr::kable(caption = "Permutation test")
```

```{r}
pairwisePermutationTest(time ~ size, data = res, method = "fdr") %>% 
  as_tibble()
pairwisePermutationTest(time ~ package, data = res, method = "fdr") %>% 
  as_tibble()
pairwisePermutationTest(time ~ computer, data = res, method = "fdr") %>% 
  as_tibble()
```



# Additional Analysis

# References {-}

<div id="refs"></div>

\newpage

# Appendix {-}

log transfomation

```{r}
mod <- lm(log(time) ~ computer * size * package, data = res)
mod %>% 
  anova() %>% 
  tidy() %>% 
  knitr::kable(caption = "ANOVA output")
```

```{r}
pqq <- tibble(resid = resid(mod)) %>% 
  ggplot(aes(sample = resid)) +
  stat_qq() + 
  stat_qq_line(linetype = "dashed")

prvf <- tibble(resid = resid(mod),
             fitted = fitted(mod)) %>% 
  ggplot(aes(fitted, resid)) +
  geom_point() +
  geom_hline(yintercept = 0, linetype = "dashed")
```

```{r, fig.width=6, fig.height=3, fig.cap="Residuals plots"}
pqq + prvf
```

```{r}
mod %>% 
  pluck("residuals") %>% 
  shapiro.test() %>% 
  tidy() %>% 
  knitr::kable(caption = "Shapiro-Wilk test for normality")
```

```{r}
leveneTest(log(time) ~ computer * size * package, data = res) %>% 
  tidy() %>% 
  knitr::kable(caption = "Levene's Test for Homogeneity of Variance (center = median)")
```

Box-Cox Transformation

```{r}
mod <- lm(time^(-0.2543644) ~ computer * size * package, data = res)
mod %>% 
  anova() %>% 
  tidy() %>% 
  knitr::kable(caption = "ANOVA output")
```

```{r}
pqq <- tibble(resid = resid(mod)) %>% 
  ggplot(aes(sample = resid)) +
  stat_qq() + 
  stat_qq_line(linetype = "dashed")

prvf <- tibble(resid = resid(mod),
             fitted = fitted(mod)) %>% 
  ggplot(aes(fitted, resid)) +
  geom_point() +
  geom_hline(yintercept = 0, linetype = "dashed")
```

```{r, fig.width=6, fig.height=3, fig.cap="Residuals plots"}
pqq + prvf
```

```{r}
mod %>% 
  pluck("residuals") %>% 
  shapiro.test() %>% 
  tidy() %>% 
  knitr::kable(caption = "Shapiro-Wilk test for normality")
```

```{r}
leveneTest(time^(-0.2543644) ~ computer * size * package, data = res) %>% 
  tidy() %>% 
  knitr::kable(caption = "Levene's Test for Homogeneity of Variance (center = median)")
```